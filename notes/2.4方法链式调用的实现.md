## 方法链式调用的实现

`jQuery`的核心理念是`Write less,do more`(写得少，做的更多)，那么链式方法的设计与这个核心理念不谋而合。那么从深层次考虑这种设计其实就是一种`Internal DSL`.

> `DSL` 是指`Doomain Specifc Language`,也就是用于描述和解决特定领域问题的语言。

我们看一段链式代码：
```
    $('input[type="button"]')
      .eq(0).click(function () {
        alert('点击我！');
      }).end().eq(1)
      .click(fucntion() {
        $('input[type="button"]:eq(0)').trigger('click');
      }).end().eq(2)
      .toggle(function () {
        $('.aa').hide('slow');
      }, function () {
        $('.aa').show('show');
      })
```

看这个代码的结构，我们或多或少都能猜到含义：
- 找到type类型为button的input元素
- 找到第一个按钮，并绑定click时间处理函数
- 返回所有按钮，再找到第二个
- 为第二个按钮绑定click时间处理函数
- 为第三个按钮绑定toggle时间处理函数

那么可见`jQuery`的`Internal DSL` 形式带来的好处--编写代码时，让代码更贴近作者的思维模式；阅读代码时，让读者更容易理解代码的含义；应用`DSL`可以有效的提高系统的可维护性（缩小了实现模型和领域模型的距离，提高了实现的可读性）和灵活性，并且提供开发的效率。

jQuery的这种管道风格的DSL链式代码，总的来说：
- 节约js代码；
- 所返回的都是一个对象，可以提高代码的效率。

通过简单扩展原想方法并通过`return this`的形式来实现跨浏览器的链式调用。利用JS的简单工厂方法模式，来将所有对于同一个`DOM`对象的操作指定同一个实例。

这个原理就超简单了，如下代码：
```
aQuery().init().name()
```
分解：
```
a = aQuery();
a.init();
a.name();
```
把代码分解一下，很明显实现链式的基本条件就是要实例对象先创建好，调用自己的方法。
``` 
aQuery.prototype = {
  init:function(){
    return this;
  },
  name:function(){
    return this;
  }
}
```
所以我们如果需要链式的处理，只需要在方法内部返回当前的这个实例对象`this`就可以了，因为返回当前实例的`this`，从而又可以访问自己的原型了，这样就节省代码量，提高代码效率，代码看起来更优雅。但是这种方法有一个问题是：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。

虽然`JavaScript`是无阻塞语言，但是他并不是没阻塞，而是不能阻塞，所以他需要通过事件来驱动，异步来完成一些本需要阻塞进程的操作，这样处理只是`同步链式`，除了同步链式还有`异步链式`，异步链式`jQuery`从1.5开始就引入了`Promise`，`jQuery.Deferred`后期再讨论。






